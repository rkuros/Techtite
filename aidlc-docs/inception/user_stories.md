# Techtite ユーザーストーリー

## 0. 優先順位サマリー（MoSCoW）

> **Must**: MVP初回リリースに必須
> **Should**: MVPに含めたいが、Mustの後に着手
> **Could**: あれば良い、リソースがあれば対応
> **Won't**: 今回のMVPスコープ外（将来対応）

| ID | ストーリー概要 | 優先度 |
|----|---------------|--------|
| **Epic 1: デスクトップアプリケーション基盤** | | |
| US-1.1 | Vault起動・フォルダ選択 | **Must** |
| US-1.2 | タブで複数ファイルを開く | **Must** |
| US-1.3 | ペイン分割 | **Should** |
| US-1.4 | ウィンドウ状態の復元 | **Should** |
| US-1.5 | IPC経由ファイルI/O | **Must** |
| **Epic 2: マークダウンエディタ** | | |
| US-2.1 | Live Previewモード | **Must** |
| US-2.2 | 基本Markdown記法レンダリング | **Must** |
| US-2.3 | YAML Frontmatter GUI | **Should** |
| US-2.4 | LaTeX数式レンダリング | **Could** |
| US-2.5 | 画像埋め込みプレビュー | **Should** |
| US-2.6 | コードファイル閲覧（読み取り専用） | **Must** |
| US-2.7 | AIによるファイル読み書き | **Must** |
| **Epic 3: プロジェクト・ファイル管理** | | |
| US-3.1 | ファイルエクスプローラ | **Must** |
| US-3.2 | ファイルCRUD操作 | **Must** |
| US-3.3 | Quick Switcher | **Should** |
| US-3.4 | コマンドパレット | **Should** |
| US-3.5 | AIからファイル構造取得 | **Must** |
| **Epic 4: ナレッジベース機能** | | |
| US-4.1 | 内部リンク `[[]]` 作成 | **Must** |
| US-4.2 | 内部リンクのオートコンプリート | **Should** |
| US-4.3 | 内部リンクからの遷移 | **Must** |
| US-4.4 | バックリンク表示 | **Should** |
| US-4.5 | 未リンク言及の検出 | **Could** |
| US-4.6 | タグ管理 | **Should** |
| US-4.7 | 全文検索 | **Must** |
| US-4.8 | Graph View（グラフ表示） | **Should** |
| US-4.9 | Graph Viewフィルタリング | **Could** |
| US-4.10 | ローカルグラフ | **Could** |
| US-4.11 | AIからリンク構造取得 | **Should** |
| US-4.12 | ベクトルインデックス自動構築（ローカル） | **Should** |
| US-4.13 | セマンティック検索（自然言語クエリ） | **Should** |
| US-4.14 | AIエージェントRAGコンテキスト取得 | **Should** |
| US-4.15 | クロスプロジェクト（Vault横断）検索 | **Could** |
| US-4.16 | ナレッジ検索AIチャット | **Should** |
| US-4.17 | 外部Embedding/Vector DB連携（拡張） | **Could** |
| US-4.18 | RAG品質自動モニタリング・自動最適化 | **Could** |
| US-4.19 | 検索フィードバック自動学習ループ | **Won't** |
| **Epic 5: Git統合・透過的同期** | | |
| US-5.1 | Gitリポジトリ自動認識 | **Must** |
| US-5.2 | 変更差分表示 | **Must** |
| US-5.3 | コミット作成 | **Must** |
| US-5.4 | コミット履歴閲覧 | **Should** |
| US-5.5 | 自動ブランチ管理・マージ | **Should** |
| US-5.6 | .gitignore表示制御 | **Should** |
| US-5.7 | AIからGit操作 | **Must** |
| US-5.8 | リモートリポジトリ設定・接続 | **Must** |
| US-5.9 | バックグラウンド自動同期（push/pull） | **Must** |
| US-5.10 | 同期状態表示 | **Must** |
| US-5.11 | 競合の検知・通知・手動解決 | **Must** |
| US-5.12 | 競合のAI自動解決 | **Should** |
| **Epic 6: AIエージェント管理・ターミナル** | | |
| US-6.1 | 組み込みターミナル | **Must** |
| US-6.2 | ターミナル複数タブ（エージェント別） | **Must** |
| US-6.3 | ターミナル出力スクロールバック・検索 | **Should** |
| US-6.4 | エージェントダッシュボード（一覧・状態） | **Must** |
| US-6.5 | エージェント操作ログ閲覧 | **Should** |
| US-6.6 | エージェント起動・停止 | **Must** |
| US-6.7 | ファイル変更リアルタイム反映 | **Must** |
| US-6.8 | AIからプロジェクト構造取得 | **Must** |
| US-6.9 | AI操作ログ自動記録 | **Should** |
| US-6.10 | システムレベル操作キャプチャ（エージェント非依存） | **Must** |
| US-6.11 | アンビエントエージェント（監視・検証・是正） | **Must** |
| US-6.12 | アンビエントエージェント（ログ粒度管理・コンテンツ統括） | **Should** |
| US-6.13 | APIコスト・トークン使用量管理 | **Should** |
| US-6.14 | ログローテーション・肥大化対策 | **Should** |
| US-6.15 | エージェント実行環境サンドボックス | **Should** |
| US-6.16 | 認証情報の安全な保管 | **Should** |
| **Epic 7: エージェントセッションログ** | | |
| US-7.1 | セッション操作の自動記録 | **Must** |
| US-7.2 | デイリーログ（日単位サマリー）自動生成 | **Must** |
| US-7.3 | セッションログ一覧・閲覧 | **Must** |
| US-7.4 | ログ内リンクからファイル・コミット遷移 | **Should** |
| US-7.5 | ログ保存先・フォーマットカスタマイズ | **Should** |
| **Epic 8: ブログ公開パイプライン** | | |
| US-8.1 | セッションログ → ブログ下書きAI変換 | **Should** |
| US-8.2 | 下書きのレビュー・修正 | **Should** |
| US-8.3 | 内部リンク等の記法自動変換 | **Should** |
| US-8.4 | ワンクリックZenn公開 | **Should** |
| US-8.5 | ワンクリックNote公開 | **Could** |
| **Epic 9: SNS連携（ブログのコンパクト・高頻度版）** | | |
| US-9.1 | セッションログ → SNS要約AI変換 | **Should** |
| US-9.2 | ワンクリックX投稿 | **Should** |
| US-9.3 | ワンクリックThreads投稿 | **Could** |
| US-9.4 | 投稿テンプレート | **Could** |

### 優先度別カウント

| 優先度 | 件数 | 主な内容 |
|--------|:----:|----------|
| **Must** | 32 | アプリ基盤、エディタ、ファイル管理、内部リンク、全文検索、Git基本、透過的同期（競合検知含む）、ターミナル・エージェント管理、システムレベル操作キャプチャ、アンビエントエージェント（監視・通知）、セッションログ自動記録 |
| **Should** | 35 | ペイン分割、Properties UI、Quick Switcher、バックリンク、Graph View、自動ブランチ管理、RAGコア（ベクトルインデックス・セマンティック検索・AIチャット）、競合AI自動解決、アンビエントエージェント（ログ粒度・コンテンツ統括）、ガードレール（APIコスト管理・ログローテーション・サンドボックス・認証情報保管）、ブログAI変換・ワンクリック公開、SNS要約・X投稿 |
| **Could** | 10 | LaTeX、未リンク言及、Graph Viewフィルタ、クロスプロジェクト検索、外部Embedding/DB連携、RAG品質自動最適化、Note公開、Threads投稿、投稿テンプレート |
| **Won't** | 1 | 検索フィードバック自動学習ループ（v2以降）。他に既にMVPスコープ外として除外済み: Canvas, Dataview, CRDT, E2EE, Plugin API等 |

---

## 1. アクター定義

### アクター 1: 個人開発者

- **説明**: AI Coding Agent（Claude Code）を活用してソフトウェア開発を行う個人開発者
- **目的**:
  - プロジェクトのコードとドキュメントを一元管理したい
  - Obsidian形式のマークダウンでドキュメントを確認・編集したい
  - 開発の過程を作業日記として記録し、技術ブログとして公開したい
  - 知見をSNSで発信したい
  - 複数端末から作業内容にアクセスしたい
- **現在の課題**:
  - コードリポジトリとObsidianのドキュメントがローカルで分離している
  - 開発作業の記録からブログ公開までの作業が手動で煩雑

### アクター 2: AIエージェント（Claude Code）

- **説明**: コードとドキュメントをメインで編集するAIコーディングエージェント
- **目的**:
  - プロジェクト内のコードファイルを読み書きしたい
  - プロジェクト内のマークダウンドキュメントを読み書きしたい
  - プロジェクトの構造やナレッジベースを参照して、コンテキストを理解したい
  - 作業ログを適切な粒度で自動生成したい
- **特性**:
  - ファイルシステムベースでアクセスする（CLI / ファイル読み書き）
  - Gitを通じたバージョン管理操作を行う

### アクター 3: アンビエントエージェント（マネージャー）

- **説明**: 全作業エージェントを監視・管理する常駐型エージェント。会社におけるマネージャーの役割を担う
- **目的**:
  - 作業エージェントが必須タスク（ログ記録、同期等）を確実に実行しているか検証したい
  - システムレベルの生操作データを、目的に応じた適切な粒度で構造化したい
  - セッションログからブログ/SNSコンテンツへの変換パイプラインを統括したい
  - 問題発生時に自動是正し、解決不能な場合のみ人間にエスカレーションしたい
- **特性**:
  - バックグラウンドで常時稼働する
  - 作業エージェントとは独立したプロセスとして動作する（監視対象と監視者の分離）
  - 人間とのインターフェースはダッシュボード・アラート通知

---

## 2. エピック定義（MVPスコープ）

> **MVPに含めるObsidian機能**: コアセット + Graph View
> **MVPから除外（後回し）**: Canvas、Dataviewクエリエンジン、ブロックリファレンス、プラグインAPI/拡張システム、CRDT同期、E2EE暗号化、CSSテーマシステム

### Epic 1: デスクトップアプリケーション基盤

Tauriベースのデスクトップアプリケーションシェル。ローカルファイルシステムへのアクセス、ウィンドウ管理、アプリケーションの起動・終了など、すべての機能の土台となる基盤。

- Tauriフレームワークによるデスクトップアプリ（macOS優先）
- Rustバックエンド + Webフロントエンド構成
- ローカルファイルシステムI/O（IPC経由）
- ウィンドウ管理（ペイン分割、タブ）

### Epic 2: マークダウンエディタ（コアエディタ）

CodeMirror 6ベースのLive Preview対応マークダウンエディタ。人間がマークダウンドキュメントを編集する主要インターフェース（Obsidian準拠）。コードファイルは閲覧・レビュー用途がメイン。

- CodeMirror 6によるLive Previewモード（非破壊的レンダリング）
- Markdownの基本記法サポート（見出し、リスト、太字、イタリック、コードブロック、引用等）
- YAML Frontmatter / Properties UI（メタデータのGUI編集）
- 数式（LaTeX）、画像埋め込みのレンダリング
- コードファイルの閲覧（シンタックスハイライト付きリードオンリービュー）

### Epic 3: プロジェクト・ファイル管理

フォルダベースのプロジェクト管理機能。ファイルエクスプローラ、ナビゲーション、コマンド実行を統合する。

- ファイルエクスプローラ（フォルダツリー表示）
- ファイルの作成・移動・削除・リネーム
- Quick Switcher（インデックスベースのファジー検索によるファイル遷移）
- コマンドパレット（全アクションの文字列検索呼び出し）

### Epic 4: ナレッジベース機能

Obsidianの核となるナレッジ管理機能。ノート間のリンク構造を構築し、情報の関係性を活用する。

- 内部リンク `[[]]` 記法のサポート（オートコンプリート付き）
- バックリンク表示（被リンク一覧）
- 未リンク言及の検出（Could: テキスト上でリンクされていないがノート名と一致する言及の解析）
- タグ管理（`#tag` 記法、タグ一覧・フィルタリング）
- 全文検索（Rustバックエンドの検索エンジン、Tantivy/SQLite FTS5）
- Graph View（ノート間のネットワーク可視化）
  - d3-force物理シミュレーション（center/repel/link force）
  - Web Workerでのバックグラウンド計算
  - タグ・フォルダによるフィルタリング
  - ローカルグラフ（選択ノートから2-3ホップ）
- ベクトルインデックス / RAG（セマンティック検索基盤）
  - ローカルEmbeddingモデル（ONNX Runtime）によるベクトル生成
  - ローカルVector Store（sqlite-vss等）
  - セマンティック検索（自然言語クエリ）
  - AIエージェント向けRAGコンテキスト取得API
  - クロスプロジェクト（Vault横断）検索
  - ナレッジ検索AIチャット
  - 設定でオン/オフ切替可能（デフォルト: オン）
  - 拡張: 外部Embedding API / 外部Vector DB連携

### Epic 5: Git統合・透過的同期

Gitをバージョン管理と複数端末間同期の基盤として利用するが、**一般ユーザーにはGitを意識させない**。UIとしては「普通のアプリの同期」として見せる（Obsidianの有料同期オプションに相当）。ブランチ切り・push/pull・マージ等はバックグラウンドでエージェントまたはシステムが自動実行する。

- Gitリポジトリの認識と初期化
- コミット・差分表示・履歴閲覧（開発者向け詳細ビュー）
- 自動ブランチ管理・マージ（ユーザーは意識しない）
- .gitignore対応
- バックグラウンド自動同期（push/pull）
- 同期状態の表示（同期中/完了/エラー）
- 競合の検知・通知・手動解決（Phase 2でAI自動解決）

### Epic 6: AIエージェント管理・ターミナル

複数のClaude Codeエージェントを同一プロジェクト内で並列稼働させる管理基盤。組み込みターミナルとエージェントダッシュボードを提供し、AI主導の開発ワークフローを実現する。加えて、**アンビエントエージェント（マネージャー役）**がすべての作業エージェントを監視し、記録整理・コンテンツ管理を統括する。

- 組み込みターミナル（複数タブ対応、各エージェントの入出力を個別管理）
- エージェントダッシュボード（稼働中エージェント一覧、状態、操作ログ）
- 複数AIエージェントの起動・停止・管理
- プロジェクト構造・ナレッジベースのコンテキスト提供
- AI操作による作業ログの自動生成
- AIエージェントによるファイル変更のリアルタイム検出・エディタ反映
- **システムレベル操作キャプチャ（エージェント非依存の確実な記録）**
- **アンビエントエージェント（マネージャー）**
  - 作業エージェントの監視・必須タスク完了チェック・自動是正
  - セッションログの粒度管理・構造化（生データ → 人間が読めるログ）
  - コンテンツパイプライン（ブログ/SNS）の実行管理・品質チェック

### Epic 7: エージェントセッションログ

AIエージェントの作業記録を自動的にセッションログとして保存する。**素材はシステムレベルで決定的にキャプチャされ（忘れない）、アンビエントエージェントが適切な粒度で構造化する。** 人間は編集せず、参照・レビュー用途。後続のブログ公開パイプラインの入力データとなる。

- システムレベルの生操作データキャプチャ（エージェント非依存）
- アンビエントエージェントによる構造化セッションログ生成（粒度制御付き）
- 操作内容（編集ファイル、コミット、実行コマンド等）の構造化ログ
- セッションログの閲覧・検索・参照
- 過去のセッションログへのアクセス（日付・エージェント別）

### Epic 8: ブログ公開パイプライン

セッションログやナレッジからブログ記事の下書きを自動生成し、人間のレビュー後にワンクリックでZenn/Noteに公開するパイプライン。

- セッションログからブログ下書きの自動生成（AI利用）
- 人間によるブログ下書きのレビュー・修正
- 内部リンク等のTechtite固有記法の自動変換
- ワンクリックでZennに公開
- ワンクリックでNoteに公開

### Epic 9: SNS連携

セッションログやナレッジからコンパクトな要約を生成し、X/Threadsに高頻度で投稿する。ブログ公開（Epic 8）のコンパクト・高頻度版。

- セッションログからSNS向けコンパクト要約の自動生成（AI利用）
- 人間によるレビュー後、ワンクリックでX/Threadsに投稿
- 投稿テンプレートのカスタマイズ

---

## 3. ユーザーストーリーと受け入れ基準

### Epic 1: デスクトップアプリケーション基盤

**US-1.1** [Must] 個人開発者として、アプリケーションを起動してプロジェクトフォルダ（Vault）を開きたい。なぜなら、ローカルに保存されたプロジェクトのコードとドキュメントにすぐにアクセスしたいからだ。

- [ ] アプリ起動時にフォルダ選択ダイアログ、または前回のVaultを自動で開ける
- [ ] 選択したフォルダ内のファイル・フォルダ構造が正しく読み込まれる
- [ ] 存在しないパスを指定した場合にエラーメッセージが表示される

**US-1.2** [Must] 個人開発者として、複数のファイルをタブで同時に開きたい。なぜなら、コードファイルとドキュメントを並行して参照・編集する必要があるからだ。

- [ ] ファイルをクリックまたはQuick Switcherで開くとタブが追加される
- [ ] タブをクリックして表示を切り替えられる
- [ ] タブの閉じるボタンまたはショートカットでタブを閉じられる
- [ ] 未保存の変更があるタブにインジケータが表示される

**US-1.3** [Should] 個人開発者として、エディタ画面をペイン分割して複数ファイルを同時表示したい。なぜなら、コードを書きながら関連ドキュメントを参照したいからだ。

- [ ] 水平・垂直方向にペインを分割できる
- [ ] 各ペインで独立したタブを管理できる
- [ ] ペインの境界をドラッグしてサイズを調整できる

**US-1.4** [Should] 個人開発者として、前回終了時のウィンドウ状態（開いていたタブ・ペイン配置）が復元されてほしい。なぜなら、毎回作業環境を再構築する手間を省きたいからだ。

- [ ] アプリ終了時にウィンドウサイズ・位置・タブ・ペイン配置が保存される
- [ ] 次回起動時に前回の状態が復元される

**US-1.5** [Must] AIエージェントとして、IPC経由でローカルファイルシステムの読み書きができるようにしたい。なぜなら、プロジェクト内のコードとドキュメントをプログラム的に操作する必要があるからだ。

- [ ] Vault内のファイルの読み取り・書き込み・作成・削除がIPC経由で実行できる
- [ ] ファイル変更イベントがフロントエンドに通知される
- [ ] Vault外へのアクセスが制限される（セキュリティ）

---

### Epic 2: マークダウンエディタ（コアエディタ）

> **設計方針**: 人間のマークダウン編集はObsidian準拠（Live Preview）。コードファイルは人間がほぼ書き直さないため、閲覧・レビュー用途に特化。

**US-2.1** [Must] 個人開発者として、マークダウンファイルをLive Previewモードで編集したい。なぜなら、ソースコードを直接編集しながら、整形された表示を同時に確認したいからだ。

- [ ] カーソルがある行はMarkdownソースが表示される
- [ ] カーソルが離れた行はリッチな表示（レンダリング済み）に変換される
- [ ] 元のプレーンテキストが破壊されない（非破壊的レンダリング）
- [ ] ソースモードとLive Previewモードを切り替えられる

**US-2.2** [Must] 個人開発者として、見出し・リスト・太字・イタリック・コードブロック・引用・テーブル等の基本的なMarkdown記法が正しくレンダリングされてほしい。なぜなら、構造化されたドキュメントを快適に読み書きしたいからだ。

- [ ] 見出し（h1〜h6）がフォントサイズ・スタイルで区別して表示される
- [ ] 順序付き/順序なしリスト・チェックリストが正しくレンダリングされる
- [ ] 太字・イタリック・取り消し線・インラインコードが視覚的に反映される
- [ ] コードブロックがシンタックスハイライト付きで表示される
- [ ] 引用・テーブル・水平線が正しく表示される

**US-2.3** [Should] 個人開発者として、ファイルのYAML FrontmatterをGUIで視覚的に編集したい。なぜなら、YAMLの構文エラーを気にせずメタデータ（タイトル、タグ、日付等）を安全に管理したいからだ。

- [ ] YAML Frontmatterがエディタ上部にGUIフォームとして表示される
- [ ] 文字列、リスト、日付、チェックボックスの各データ型を視覚的に編集できる
- [ ] GUI編集の結果が正しいYAML形式でファイルに保存される
- [ ] YAML構文が壊れないことが保証される

**US-2.4** [Could] 個人開発者として、数式（LaTeX記法）がエディタ上でレンダリングされてほしい。なぜなら、技術ドキュメントで数式を使用することがあるからだ。

- [ ] インライン数式（`$...$`）がLive Previewで数式としてレンダリングされる
- [ ] ブロック数式（`$$...$$`）がLive Previewで数式としてレンダリングされる

**US-2.5** [Should] 個人開発者として、画像をマークダウン内に埋め込み、エディタ上でプレビュー表示したい。なぜなら、スクリーンショットや図をドキュメントに含めて確認したいからだ。

- [ ] `![alt](path)` 記法の画像がLive Previewで表示される
- [ ] Vault内の相対パスの画像が正しく解決・表示される
- [ ] 画像が存在しない場合にエラー表示（プレースホルダ）が出る

**US-2.6** [Must] 個人開発者として、コードファイル（.ts, .py, .rs等）をシンタックスハイライト付きで閲覧したい。なぜなら、AIエージェントが書いたコードの内容をレビューしたいからだ。

- [ ] コードファイルを開くとシンタックスハイライト付きで表示される
- [ ] 行番号が表示される
- [ ] 読み取り専用モードがデフォルトとなる（編集ロック表示付き）
- [ ] 必要に応じて編集モードに切り替えられる

**US-2.7** [Must] AIエージェントとして、マークダウンファイルおよびコードファイルの内容をプレーンテキストとして読み書きしたい。なぜなら、ドキュメント・コードの生成・編集をプログラム的に行うからだ。

- [ ] ファイルの内容をプレーンテキスト（UTF-8）として読み取れる
- [ ] プレーンテキストを書き込むとファイルとして正しく保存される
- [ ] ファイルの保存後、エディタの表示が自動的に更新される

---

### Epic 3: プロジェクト・ファイル管理

**US-3.1** [Must] 個人開発者として、サイドバーにフォルダツリー形式のファイルエクスプローラを表示したい。なぜなら、プロジェクト全体の構造を把握しながらファイルにアクセスしたいからだ。

- [ ] サイドバーにVault内のフォルダ・ファイルがツリー構造で表示される
- [ ] フォルダの展開・折りたたみができる
- [ ] ファイルをクリックするとエディタで開かれる
- [ ] ファイルシステムの変更（外部からの追加・削除含む）がリアルタイムで反映される

**US-3.2** [Must] 個人開発者として、ファイルやフォルダの作成・移動・削除・リネームをアプリ内で行いたい。なぜなら、プロジェクトの整理をエディタから離れずに行いたいからだ。

- [ ] 右クリックメニューまたはショートカットで新規ファイル・フォルダを作成できる
- [ ] ドラッグ＆ドロップまたは右クリックメニューでファイルを移動できる
- [ ] ファイル・フォルダの削除ができる（確認ダイアログ付き）
- [ ] ファイル・フォルダのリネームができる
- [ ] ファイル移動・リネーム時に内部リンクが自動更新される

**US-3.3** [Should] 個人開発者として、Quick Switcher（ファジー検索）でファイル名を入力して素早くファイルを開きたい。なぜなら、大量のファイルの中から目的のファイルにキーボード操作だけで瞬時にアクセスしたいからだ。

- [ ] ショートカットキーでQuick Switcherモーダルが開く
- [ ] 入力に応じてファジーマッチでファイル名候補がリアルタイム表示される
- [ ] EnterキーまたはクリックでファイルID選択・遷移できる
- [ ] 候補表示が高速（入力から100ms以内、p95）である（ベースライン: M1 Mac、Vault 10,000ファイル/1GB規模、ウォーム状態。コールドスタート時は初回インデックス構築後に同等性能）

**US-3.4** [Should] 個人開発者として、コマンドパレットからアプリケーション内のすべてのアクションを検索・実行したい。なぜなら、メニューを探す手間なく、キーボードだけで効率的に操作したいからだ。

- [ ] ショートカットキーでコマンドパレットが開く
- [ ] 登録されたすべてのコマンドがテキスト検索で絞り込める
- [ ] コマンド選択で対応するアクションが実行される
- [ ] 各コマンドにキーボードショートカットが表示される

**US-3.5** [Must] AIエージェントとして、プロジェクト内のファイル一覧とフォルダ構造を取得したい。なぜなら、プロジェクトの全体像を把握した上でコードやドキュメントを適切に配置したいからだ。

- [ ] API経由でVault内の.gitignore適用後の全ファイル・フォルダのツリー構造を取得できる
- [ ] 各ファイルのパス、サイズ、更新日時等のメタデータが含まれる

---

### Epic 4: ナレッジベース機能

**US-4.1** [Must] 個人開発者として、`[[ファイル名]]` 記法で他のノートへの内部リンクを作成したい。なぜなら、関連するノート同士を結びつけてナレッジのネットワークを構築したいからだ。

- [ ] `[[` を入力するとリンク作成モードに入る
- [ ] `[[ファイル名]]` がLive Previewでリンクとして視覚的に区別される
- [ ] 存在しないファイルへのリンクが色やスタイルで区別される

**US-4.2** [Should] 個人開発者として、内部リンクを入力する際にオートコンプリートで既存ファイル名の候補が表示されてほしい。なぜなら、正確なファイル名を覚えていなくても素早くリンクを作成したいからだ。

- [ ] `[[` の後にテキストを入力すると候補リストが表示される
- [ ] 候補はファジーマッチで絞り込まれる
- [ ] 候補を選択すると `[[ファイル名]]` が補完される

**US-4.3** [Must] 個人開発者として、内部リンクをクリックしてリンク先のノートに直接遷移したい。なぜなら、関連情報にシームレスにアクセスしたいからだ。

- [ ] 内部リンクをクリック（またはCtrl+クリック）するとリンク先ファイルが開く
- [ ] リンク先が存在しない場合、新規ファイル作成の確認が表示される

**US-4.4** [Should] 個人開発者として、現在のノートに対するバックリンク（他のノートからのリンク）を一覧表示したい。なぜなら、どのノートが現在のノートを参照しているかを把握し、情報の関係性を理解したいからだ。

- [ ] サイドパネルまたはエディタ下部にバックリンク一覧が表示される
- [ ] 各バックリンクにリンク元ファイル名と該当箇所の前後テキストが表示される
- [ ] バックリンクをクリックするとリンク元ファイルの該当箇所に遷移する

**US-4.5** [Could] 個人開発者として、テキスト上でリンクされていないが、ノート名と一致する言及（未リンク言及）も検出・表示してほしい。なぜなら、明示的にリンクを貼っていない関連ノートを発見したいからだ。

- [ ] バックリンクパネルに「未リンク言及」セクションが表示される
- [ ] ノート名と一致するテキストがVault内から検出・一覧表示される
- [ ] 未リンク言及をクリックして内部リンクに変換できる

**US-4.6** [Should] 個人開発者として、`#タグ` 記法でノートにタグを付与し、タグ一覧を閲覧・フィルタリングしたい。なぜなら、フォルダ構造とは別の軸でノートを分類・検索したいからだ。

- [ ] `#タグ名` がエディタ上でタグとして視覚的に区別される
- [ ] Vault内のすべてのタグを一覧表示するパネルがある
- [ ] タグをクリックするとそのタグを持つノートの一覧が表示される
- [ ] ネストされたタグ（`#parent/child`）がサポートされる

**US-4.7** [Must] 個人開発者として、プロジェクト内の全ファイルを対象にキーワードで全文検索したい。なぜなら、どのファイルに目的の情報が書かれているかを素早く見つけたいからだ。

- [ ] 検索パネルでキーワードを入力すると.gitignore適用後の全ファイルを対象に検索が実行される
- [ ] 検索結果にファイル名と一致箇所のプレビューが表示される
- [ ] 検索結果をクリックすると該当ファイルの該当箇所に遷移する
- [ ] 検索が高速（1秒以内、p95）に完了する（ベースライン: M1 Mac、Vault 10,000ファイル/1GB規模、ウォーム状態。コールドスタート時は初回インデックス構築後に同等性能）

**US-4.8** [Should] 個人開発者として、Graph Viewでノート間のリンク関係をネットワークグラフとして可視化したい。なぜなら、ナレッジ全体の構造や隠れた関連性を直感的に把握したいからだ。

- [ ] ノートがノード、内部リンクがエッジとしてグラフ描画される
- [ ] ノードをドラッグして配置を調整できる
- [ ] ノードをクリックすると対応するノートが開く
- [ ] グラフの表示がUIをブロックしない（バックグラウンド計算）

**US-4.9** [Could] 個人開発者として、Graph Viewをタグやフォルダで絞り込みたい。なぜなら、特定のトピックに関連するノート群だけを集中的に確認したいからだ。

- [ ] タグでノードをフィルタリングできる
- [ ] フォルダでノードをフィルタリングできる
- [ ] フィルタ適用後にグラフが再描画される

**US-4.10** [Could] 個人開発者として、特定のノートを起点としたローカルグラフ（2-3ホップ先まで）を表示したい。なぜなら、大量のノートがある中で、今関連しているノート群のみを効率的に確認したいからだ。

- [ ] 現在開いているノートを起点としたローカルグラフを表示できる
- [ ] 表示する深さ（ホップ数）を設定できる（デフォルト: 2）
- [ ] ローカルグラフ内のノードをクリックすると該当ノートが開く

**US-4.11** [Should] AIエージェントとして、ノート間のリンク構造（内部リンク・バックリンク・タグ）を参照したい。なぜなら、プロジェクトのナレッジ構造を理解した上で、適切なコンテキストでドキュメントを生成・編集したいからだ。

- [ ] API経由で指定ファイルの内部リンク一覧を取得できる
- [ ] API経由で指定ファイルのバックリンク一覧を取得できる
- [ ] API経由でVault内の全タグとそれに紐づくファイル一覧を取得できる

#### ベクトルインデックス / RAG（セマンティック検索）

> **設計方針**: ローカルファーストでベクトルインデックスを構築し、キーワード検索（US-4.7）では拾えない意味的な関連性を検索可能にする。設定でオン/オフ切替可能（デフォルト: オン）。将来的に外部Embedding API・外部Vector DBへの拡張も可能とする。
>
> **データスコープ原則**: RAGインデックス対象 = Git同期対象 = .gitignore適用後のVault内ファイル。生ログ・操作ログ・ベクトルインデックス自体はローカル専用でGitにもRAGにも含めない。
> **Git未初期化時**: Gitリポジトリが存在しないVaultでは、.gitignoreによる除外が適用されないため、RAGはVault内の全ファイルを対象とする（Techtiteローカル専用データは除外）。Git初期化後に.gitignoreスコープへ自動移行する。

**US-4.12** [Should] 個人開発者として、Vault内のドキュメントが自動的にベクトルインデックス化されてほしい。なぜなら、手動でインデックスを管理せず、常に最新の状態でセマンティック検索を利用したいからだ。

- [ ] .gitignore適用後のVault内ファイル（Git同期対象と同一スコープ）がローカルEmbeddingモデル（ONNX Runtime等）で自動ベクトル化される
- [ ] ファイルの作成・編集・削除時にインデックスが差分更新される
- [ ] マークダウンの構造（見出し・セクション単位）を考慮したチャンキングが行われる
- [ ] インデックス構築はバックグラウンドで実行され、UIをブロックしない
- [ ] 設定でRAG機能のオン/オフを切り替えられる（デフォルト: オン）
- [ ] ローカルVector Store（sqlite-vss等）にインデックスが保存される
- [ ] ベクトルインデックスは各端末で独自に生成される（Git同期対象外。ソースドキュメントから再生成可能な派生データとして扱う）
- [ ] 新しい端末でVaultを開いた際、バックグラウンドでインデックスが自動構築される
- [ ] バックグラウンドインデックス構築のCPU/メモリ使用量に上限が設定される（デフォルト: 論理コア数の75%以下、メモリ2GB以下。設定で調整可能）
- [ ] インデックス構築キューの同時処理数が制限される（デフォルト: 同時4ファイルまで。設定で調整可能）
- [ ] （拡張）中央集約型Vector DBが必要な場合はクラウドデプロイオプションとして提供（US-4.17）

**US-4.13** [Should] 個人開発者として、自然言語で質問してセマンティック検索したい。なぜなら、正確なキーワードを覚えていなくても、意味的に関連するドキュメントを見つけたいからだ。

- [ ] 検索パネルでキーワード検索とセマンティック検索を切り替え（または併用）できる
- [ ] 自然言語の質問文（例:「認証周りの設計判断」）で関連ドキュメントが検索される
- [ ] 検索結果に類似度スコアと該当セクションのプレビューが表示される
- [ ] 検索結果をクリックすると該当ファイルの該当箇所に遷移する

**US-4.14** [Should] AIエージェントとして、セマンティック検索を利用してタスクに関連するドキュメント・コードのコンテキストを取得したい。なぜなら、プロジェクト全体のナレッジから最も関連性の高い情報をもとに、質の高いコード・ドキュメントを生成したいからだ。

- [ ] API経由で自然言語クエリによるセマンティック検索が実行できる
- [ ] 検索結果にファイルパス、該当セクション、類似度スコアが含まれる
- [ ] 取得する結果件数（top-k）を指定できる
- [ ] キーワード検索とセマンティック検索を組み合わせたハイブリッド検索が実行できる

**US-4.15** [Could] 個人開発者として、複数のプロジェクト（Vault）を横断してセマンティック検索したい。なぜなら、過去のプロジェクトの知見を現在のプロジェクトに活用したいからだ。

- [ ] 検索対象に他のVault（プロジェクト）を追加できる
- [ ] 検索結果にVault名（プロジェクト名）が表示される
- [ ] 検索対象Vaultのフィルタリング（含める/除外する）ができる

**US-4.16** [Should] 個人開発者として、ナレッジベースに対してチャット形式で質問したい。なぜなら、検索キーワードを考えるのではなく、会話的にプロジェクトの情報を引き出したいからだ。

- [ ] ナレッジ検索専用のAIチャットパネルが開ける
- [ ] チャットの質問に対し、ローカルのベクトルインデックスから関連ドキュメントを検索（RAG）した上でAIが回答する
- [ ] 回答に参照元ドキュメントへのリンクが含まれる
- [ ] 会話の文脈を保持して連続的に質問できる

**US-4.17** [Could] 個人開発者として、Embeddingモデルやベクトルデータベースを外部サービスに切り替えたい。なぜなら、より高品質なモデルや大規模なベクトルDBを利用したいケースがあるからだ。

- [ ] 設定画面でEmbeddingモデルを切り替えられる（ローカル/外部API）
- [ ] 外部Embedding API（OpenAI等）のエンドポイント・認証情報を設定できる
- [ ] 外部Vector DB（Qdrant, Pinecone等）への接続設定ができる
- [ ] ローカルモードと外部モードをプロジェクト単位で切り替えられる

**US-4.18** [Could] 個人開発者として、RAGの検索精度が自動的にモニタリングされ、精度低下時にパラメータ調整とインデックス再構築が自動実行されてほしい。なぜなら、RAGの品質管理を手動で行う専門知識がなくても、常に高品質な検索結果を得たいからだ。

- [ ] バックグラウンドエージェントがサンプルクエリで検索品質スコアを定期的に自動測定する
- [ ] インデックスのヘルス指標（カバレッジ率、鮮度、断片化率）がダッシュボードで確認できる
- [ ] 品質スコアが閾値を下回った場合、パラメータ（チャンクサイズ、オーバーラップ率、ハイブリッド検索重み等）の自動チューニングが実行される
- [ ] チューニング後にインデックスの自動再構築がバックグラウンドで実行される
- [ ] 再構築前後の品質スコア比較が記録され、改善を確認できる
- [ ] リランキング（Cross-Encoderによる検索結果の精密再順位付け）が自動適用される

**US-4.19** [Won't] 個人開発者として、日常の検索行動から暗黙的にフィードバックが収集され、検索精度が継続的に改善されてほしい。なぜなら、明示的な評価操作をしなくても、使えば使うほど検索が賢くなってほしいからだ。

- [ ] 検索結果のクリック位置・スキップパターンが暗黙フィードバックとして収集される
- [ ] AIチャット（US-4.16）での質問と参照ドキュメントの関連性がフィードバックとして記録される
- [ ] 収集されたフィードバックがRAG品質スコアの算出に反映される
- [ ] フィードバックデータはローカルに保存され、外部に送信されない（プライバシー保護）

---

### Epic 5: Git統合・透過的同期

> **設計方針**: Gitをバージョン管理と同期の内部メカニズムとして利用するが、一般ユーザーにはGitの存在を意識させない。push/pull/ブランチ/マージはバックグラウンドでシステムまたはエージェントが自動実行し、UIは通常のアプリの「同期」として見せる。

**US-5.1** [Must] 個人開発者として、プロジェクトフォルダ内のGitリポジトリを自動的に認識してほしい。なぜなら、コードとドキュメントが同じリポジトリにあることを前提に作業したいからだ。

- [ ] Vault内に`.git`ディレクトリがある場合、自動的にGitリポジトリとして認識される
- [ ] ステータスバーに現在のブランチ名が表示される
- [ ] Gitリポジトリが存在しない場合は、Git機能が無効化される

**US-5.2** [Must] 個人開発者として、ファイルの変更差分をアプリ内で確認したい。なぜなら、コミット前にどのような変更を行ったかを確認したいからだ。

- [ ] 変更のあるファイルの一覧が表示される（staged / unstaged / untracked）
- [ ] ファイルを選択すると追加・削除・変更行が色分け表示される

**US-5.3** [Must] 個人開発者として、アプリ内からコミットメッセージを入力してコミットを作成したい。なぜなら、コードとドキュメントの変更を一つのコミットとしてまとめて記録したいからだ。

- [ ] ファイルのステージ（add）操作ができる
- [ ] コミットメッセージを入力してコミットを実行できる
- [ ] コミット成功後、変更ファイル一覧がリセットされる

**US-5.4** [Should] 個人開発者として、コミット履歴を閲覧したい。なぜなら、プロジェクトの変更履歴を振り返り、いつどのような変更があったかを追跡したいからだ。

- [ ] コミット履歴がリスト形式で表示される（メッセージ、作者、日時）
- [ ] コミットを選択すると、そのコミットの変更ファイル・差分が表示される

**US-5.5** [Should] 個人開発者として、ブランチの作成・切り替え・マージがバックグラウンドで自動的に管理されてほしい。なぜなら、Gitの複雑な操作を意識せず、普通のアプリのように使いたいからだ。

- [ ] 必要に応じてブランチが自動作成される（エージェントまたはシステムによる）
- [ ] マージが自動で実行される
- [ ] マージ競合が発生した場合にユーザーに通知され、エージェントが自動解決を試みる
- [ ] 開発者向けオプションとして、手動でのブランチ操作も可能

**US-5.6** [Should] 個人開発者として、.gitignoreに基づいてファイルエクスプローラの表示を制御したい。なぜなら、ビルド成果物やnode_modules等の不要なファイルをプロジェクト表示から除外したいからだ。

- [ ] .gitignoreに記載されたパターンに一致するファイル・フォルダがエクスプローラから非表示になる
- [ ] .gitignoreパターンが全文検索（US-4.7）のインデックス対象から除外される
- [ ] .gitignoreパターンがベクトルインデックス（US-4.12）の対象から除外される
- [ ] .gitignoreパターンがAIエージェントのファイル一覧取得（US-3.5）から除外される
- [ ] 非表示/表示の切り替えオプションがある（システム全体で一括、または機能別に個別設定可能）
- [ ] Techtiteが生成するローカル専用データ（生ログ、操作ログ、ベクトルインデックス）が.gitignoreに自動登録される

**US-5.7** [Must] AIエージェントとして、Gitの操作（コミット、差分確認等）をプログラム的に実行したい。なぜなら、コードとドキュメントの変更を自動的にバージョン管理したいからだ。

- [ ] API経由でステージ・コミット・差分取得が実行できる
- [ ] API経由でブランチ一覧・現在のブランチを取得できる

#### 透過的同期（Git push/pullの自動化）

**US-5.8** [Must] 個人開発者として、リモートリポジトリ（GitHub等）への接続を簡単に設定したい。なぜなら、一度設定すれば自動同期が始まる仕組みにしたいからだ。

- [ ] 設定画面でリモートリポジトリURL・認証情報を設定できる
- [ ] Personal Access Token（PAT）またはSSHキーによる認証設定ができる
- [ ] 接続テスト（疎通確認）ができる
- [ ] 設定完了後、自動同期が即座に有効になる
- [ ] （拡張）GitHub/GitLab等のOAuth認証でワンクリック設定ができる

**US-5.9** [Must] 個人開発者として、ファイルの変更がバックグラウンドでリモートリポジトリに自動同期されてほしい。なぜなら、Gitの操作を意識せず、普通のアプリのクラウド同期のように使いたいからだ。

- [ ] 一定時間窓（デフォルト: 5分）内の変更をバッチで1コミットにまとめ、バックグラウンドでcommit + pushが実行される
- [ ] コミットメッセージはAIがローカルで変更内容から自動生成する（例:「docs: セッションログ追加, fix: 認証モジュール修正」）。**差分・変更内容は外部LLM/外部サービスに送信しない（オンデバイス生成 or テンプレートフォールバック）**
- [ ] アプリ起動時にリモートの変更が自動的にpullされる
- [ ] 同期のタイミング（時間窓の長さ/手動のみ）を設定で選択できる
- [ ] 手動コミット（US-5.3）との併用が可能。手動コミットが行われた場合、その時点で自動バッチはリセットされる
- [ ] 自動コミットと手動コミットが履歴上で区別できる（自動コミットにはラベル/プレフィックス付与）

**US-5.10** [Must] 個人開発者として、同期の状態をステータスバーで確認したい。なぜなら、データが最新の状態に保たれているか安心して作業したいからだ。

- [ ] ステータスバーに同期状態アイコンが表示される（同期中/完了/エラー）
- [ ] 最終同期日時が表示される
- [ ] エラーが発生した場合にエラー詳細を確認できる
- [ ] 手動で「今すぐ同期」ボタンを押して即座に同期を実行できる

**US-5.11** [Must] 個人開発者として、同期の競合が発生した場合に通知を受け、簡単な操作で解決したい。なぜなら、Gitのマージ競合を自分で解決する知識がなくても安心して使いたいからだ。

- [ ] ローカルとリモートの変更が競合した場合に、ユーザーに通知される
- [ ] 「ローカル優先/リモート優先」の選択肢がシンプルなUIで提示される
- [ ] 「AIに相談する」ボタンで、エージェントに競合内容の解説と解決提案を求められる
- [ ] バイナリファイルの競合は自動検出され、選択肢（どちらを採用するか）が提示される
- [ ] 競合解決の履歴がログとして保存される

**US-5.12** [Should] 個人開発者として、同期の競合がエージェントにより自動解決されてほしい。なぜなら、競合のたびに手動で対応するのは煩雑だからだ。

- [ ] テキストファイルの競合に対し、エージェントがコンテキストを理解した上で自動マージを試みる
- [ ] 自動解決できた場合はユーザーに通知のみ表示される（変更内容の差分確認リンク付き）
- [ ] 自動解決の信頼度が低い場合は、手動確認を促す（US-5.11にフォールバック）
- [ ] 大量の競合が同時発生した場合の処理上限（バッチサイズ）が設定可能

---

### Epic 6: AIエージェント管理・ターミナル

> **設計方針**: 人間はコードをほぼ書かず、複数のClaude Codeエージェントを同一プロジェクト内で並列稼働させて開発を進める。ターミナルとダッシュボードで各エージェントの状態・出力を管理する。

#### 組み込みターミナル

**US-6.1** [Must] 個人開発者として、アプリ内に組み込みターミナルを開きたい。なぜなら、AIエージェントの操作やシェルコマンドをエディタから離れずに実行したいからだ。

- [ ] ペイン下部またはタブとしてターミナルを開ける
- [ ] ショートカットキーでターミナルの表示/非表示を切り替えられる
- [ ] 標準的なシェル（zsh/bash）が動作する

**US-6.2** [Must] 個人開発者として、ターミナルを複数タブで開き、各AIエージェントの入出力を個別に確認したい。なぜなら、複数のエージェントが並列で作業している内容をそれぞれ追跡したいからだ。

- [ ] 新しいターミナルタブを追加できる
- [ ] 各タブにエージェント名や用途のラベルを付けられる
- [ ] タブ間を切り替えて各ターミナルの出力を確認できる
- [ ] 各ターミナルの出力が独立してスクロール・保持される

**US-6.3** [Should] 個人開発者として、ターミナルの出力をスクロールバックして過去の実行結果を確認したい。なぜなら、AIエージェントの長い出力の中から特定の情報を探したいからだ。

- [ ] ターミナル出力のスクロールバックが十分な行数保持される
- [ ] ターミナル出力内をテキスト検索できる

#### エージェントダッシュボード

**US-6.4** [Must] 個人開発者として、現在稼働中のAIエージェント一覧とその状態を一目で確認したい。なぜなら、複数のエージェントがそれぞれ何をしているか把握したいからだ。

- [ ] ダッシュボードパネルに稼働中エージェントの一覧が表示される
- [ ] 各エージェントの状態（実行中/待機中/完了/エラー）が視覚的に表示される
- [ ] 各エージェントの現在の作業内容（最新の操作やメッセージ）が要約表示される

**US-6.5** [Should] 個人開発者として、各AIエージェントの操作ログ（作成・編集・削除したファイル）を時系列で閲覧したい。なぜなら、どのエージェントがどのファイルにどのような変更を行ったかを追跡したいからだ。

- [ ] エージェントごとの操作ログを時系列で表示できる
- [ ] ログにはタイムスタンプ、操作種別、対象ファイルパス、変更概要が含まれる
- [ ] ログエントリから該当ファイルに遷移できる
- [ ] 全エージェントの操作を統合した時系列ビューも表示できる

**US-6.6** [Must] 個人開発者として、ダッシュボードからAIエージェントを起動・停止したい。なぜなら、必要に応じてエージェントの数を調整し、リソースを管理したいからだ。

- [ ] ダッシュボードから新しいエージェントを起動できる
- [ ] 稼働中のエージェントを停止できる
- [ ] エージェント起動時に作業内容やコンテキストを指定できる

#### AIエージェントのファイル連携

**US-6.7** [Must] 個人開発者として、AIエージェントが編集したファイルの変更をエディタにリアルタイムで反映してほしい。なぜなら、AIの作業結果を即座に確認・レビューしたいからだ。

- [ ] 外部プロセス（Claude Code）によるファイル変更がファイルシステム監視で検出される
- [ ] 検出された変更がエディタの表示に自動反映される
- [ ] 編集中のファイルが外部変更された場合、競合の通知が表示される
- [ ] どのエージェントによる変更かが識別できる

**US-6.8** [Must] AIエージェントとして、プロジェクトの構造情報（フォルダ構成、ファイル一覧、リンク関係、タグ情報）を取得したい。なぜなら、プロジェクト全体のコンテキストを理解した上で適切な編集を行いたいからだ。

- [ ] ファイル構造をJSON等の構造化データとして出力・取得できる
- [ ] 各ファイルのメタデータ（frontmatter、タグ、リンク）を取得できる

**US-6.9** [Should] AIエージェントとして、自身が行った操作（ファイルの作成・編集・削除）のログを自動的に記録したい。なぜなら、個人開発者が後からAIの作業内容を確認・追跡できるようにしたいからだ。

- [ ] AIエージェントによるファイル操作が操作ログに自動記録される
- [ ] ログにはエージェント識別子、タイムスタンプ、操作種別、対象ファイルパスが含まれる
- [ ] 操作ログはローカル専用ストレージに保存され、Git同期対象から除外される

#### システム信頼性・アンビエントエージェント

> **設計方針**: AIエージェントの動作に依存する機能の信頼性を3層で担保する。
> - **第1層**: システムレベルの決定的な操作キャプチャ（エージェント非依存、忘れない）
> - **第2層**: 作業エージェント（知的処理を担当、ただし忘却リスクあり）
> - **第3層**: アンビエントエージェント（マネージャー役。監視・記録整理・コンテンツ管理）

**US-6.10** [Must] 個人開発者として、すべてのファイル操作・Git操作・コマンド実行がエージェントに依存せずシステムレベルで自動記録されてほしい。なぜなら、エージェントが記録を忘れてもデータが失われないことを保証したいからだ。

- [ ] ファイルシステムWatcherにより、Vault内のすべてのファイル操作（作成・編集・削除・移動）がリアルタイムで自動記録される
- [ ] Git操作（commit, push, pull, merge, branch）がフック経由で自動記録される
- [ ] ターミナルで実行されたコマンドとその出力が自動記録される
- [ ] 記録はエージェントの動作に一切依存しない（システムプロセスとして常時稼働）
- [ ] 記録データは構造化フォーマット（JSON/SQLite）で保存され、後続処理の素材となる
- [ ] 生ログはローカル専用ストレージに保存され、Git同期対象から除外される（自動で.gitignoreに追加）
- [ ] ログ内の秘匿情報（APIキー、パスワード、トークン等）がパターンマッチで自動マスキングされる（正規表現ベース、既知のAPIキー形式・URL埋め込みトークン等を即座に検出）
- [ ] （Phase 2）ローカルLLMによるコンテキスト解析で未知の秘匿情報を検出・マスキングする。**生ログは外部LLM/外部サービスに一切送信しない（オンデバイス限定）**
- [ ] マスキング対象パターンをカスタム定義できる（正規表現ルール）
- [ ] 生ログの閲覧には明示的な確認操作が必要（ワンクリックで秘匿情報が見えない設計）

**US-6.11** [Must] 個人開発者として、アンビエントエージェント（マネージャー）が全作業エージェントを監視し、必須タスクの実行漏れを検出・通知してほしい。なぜなら、エージェントがセッションログの記録やGit同期を忘れた場合に気づけるようにしたいからだ。

- [ ] アンビエントエージェントがバックグラウンドで常時稼働する
- [ ] 各作業エージェントの必須タスク（ログ記録、コミット、同期等）の完了を定期チェックする
- [ ] 必須タスクが未完了の場合、人間にアラート通知する
- [ ] エージェントの稼働状態・タスク完了率がダッシュボードに表示される
- [ ] チェック項目（何を必須タスクとするか）を設定で定義できる
- [ ] リトライ上限を設定可能（無限ループ防止）
- [ ] （Phase 2）未完了タスクの自動再実行指示（自動是正）

**US-6.12** [Should] 個人開発者として、アンビエントエージェントがセッションログの粒度を管理し、適切な記録と人間向けコンテンツへの変換を統括してほしい。なぜなら、エージェントの生の操作ログは膨大すぎるので、目的に応じた適切な粒度で整理・公開してほしいからだ。

- [ ] ログ粒度を設定で選択できる（詳細: 全操作記録 / 標準: 主要操作+判断 / コンパクト: マイルストーンのみ）
- [ ] システムレベルの生ログ（US-6.10）からアンビエントエージェントが構造化セッションログ（Epic 7）を自動生成する
- [ ] 日単位のデイリーサマリーを自動生成し、各エージェントの成果を統合する
- [ ] セッションログの品質（記載漏れ、不整合）を自動検証する
- [ ] ブログ/SNSへの変換パイプライン（Epic 8, 9）の実行スケジュールを管理し、未変換のログがあれば自動でパイプラインを起動する
- [ ] コンテンツ変換の品質（読みやすさ、情報の網羅性）を公開前に自動チェックする

#### ガードレール（コスト・セキュリティ・運用）

**US-6.13** [Should] 個人開発者として、AIエージェントのAPIコスト（トークン使用量）をダッシュボードで確認し、上限設定で意図しない高額請求を防ぎたい。なぜなら、複数エージェント並列稼働+RAG+アンビエントエージェントでトークン消費が大きくなるからだ。

- [ ] ダッシュボードにエージェント別・合計のトークン使用量と推定コストが表示される
- [ ] 日次/月次のコスト推移グラフが表示される
- [ ] コスト上限（日次/月次）を設定でき、上限到達時にエージェントが自動停止する
- [ ] 上限接近時に警告通知が表示される（例: 80%到達時）
- [ ] エージェント種別ごと（作業エージェント/アンビエント/RAG）のコスト内訳が確認できる

**US-6.14** [Should] 個人開発者として、システムレベルの操作ログ（US-6.10）が肥大化しないよう、自動ローテーション・圧縮してほしい。なぜなら、全操作を常時キャプチャし続けるとストレージが逼迫するからだ。

- [ ] ログの保持期間を設定できる（デフォルト: 30日）
- [ ] 保持期間を過ぎた生ログが自動圧縮（gzip等）される
- [ ] 圧縮後一定期間経過した生ログが自動パージされる（構造化セッションログは保持）
- [ ] ビルド出力等の大容量ログに対するフィルタリングルールを設定できる
- [ ] 現在のログストレージ使用量がダッシュボードに表示される

**US-6.15** [Should] 個人開発者として、AIエージェントのターミナル実行環境がサンドボックス化されてほしい。なぜなら、エージェントが意図せず破壊的なコマンドや機密情報へのアクセスを行うリスクを防ぎたいからだ。

- [ ] エージェント用ターミナルがプロジェクトディレクトリ（Vault）をルートとした制限された環境で動作する
- [ ] 許可/禁止するコマンドのホワイトリスト/ブラックリストを設定できる
- [ ] Vault外のファイルシステム（`~/.ssh`、`/etc`等）へのアクセスが制限される
- [ ] 破壊的コマンド（`rm -rf /`等）がブロックされ、実行前に確認が求められる
- [ ] （拡張）Dockerコンテナ等の隔離環境でのエージェント実行オプション

**US-6.16** [Should] 個人開発者として、外部サービスの認証情報（API Key、Token等）が安全に保管されてほしい。なぜなら、Zenn/Note/X/Threads/GitHub/OpenAI等の認証情報が漏洩するリスクを防ぎたいからだ。

- [ ] 認証情報がOS標準のキーチェーン/資格情報マネージャーに暗号化保存される
- [ ] 認証情報がプロジェクトファイルやGitリポジトリに含まれない
- [ ] 認証情報の一覧管理画面で追加・更新・削除ができる
- [ ] エージェントからの認証情報アクセスは必要最小限のスコープに制限される

---

### Epic 7: エージェントセッションログ

> **設計方針**: セッションログは2段階で生成される。
> 1. **システムレベル（US-6.10）**: 生の操作データを決定的にキャプチャ（忘れない）
> 2. **アンビエントエージェント（US-6.12）**: 生データを適切な粒度で構造化し、人間が読めるセッションログに整理
>
> 人間は編集せず、参照・レビュー用途。ブログ公開パイプライン（Epic 8）の入力データとなる。

**US-7.1** [Must] AIエージェントとして、セッション（作業期間）の操作内容を構造化ログとして自動記録したい。なぜなら、個人開発者が後から作業内容を参照・レビューできるようにしたいからだ。

- [ ] エージェントのセッション開始時にログファイルが自動作成される
- [ ] 編集ファイル、コミット内容、実行コマンド、作業の意図・判断がログに含まれる
- [ ] ログはマークダウン形式で保存される（人間が読みやすい）
- [ ] セッション終了時にログが自動的にクローズされる

**US-7.2** [Must] AIエージェントとして、日単位でその日の全セッションの作業サマリーを自動生成したい。なぜなら、１日の作業全体を俯瞰できるデイリーログを提供したいからだ。

- [ ] 日付ベースのデイリーログファイルが自動生成される
- [ ] その日に稼働した全エージェントのセッションが統合される
- [ ] 主要な変更内容・作成ファイル・コミット等のサマリーが含まれる

**US-7.3** [Must] 個人開発者として、セッションログを日付・エージェント別に一覧表示して閲覧したい。なぜなら、過去にどのエージェントがいつ何をしたかを振り返りたいからだ。

- [ ] セッションログの一覧が日付順で表示される
- [ ] エージェント名でフィルタリングできる
- [ ] ログを選択するとマークダウンとしてエディタで閲覧できる

**US-7.4** [Should] 個人開発者として、セッションログ内から参照されるファイルやコミットに直接遷移したい。なぜなら、ログに記載された変更内容の詳細を確認したいからだ。

- [ ] ログ内のファイルパスがクリック可能なリンクとして表示される
- [ ] リンクをクリックすると該当ファイルがエディタで開かれる
- [ ] コミットハッシュからGit差分表示に遷移できる

**US-7.5** [Should] 個人開発者として、セッションログの保存先フォルダとファイル名フォーマットをカスタマイズしたい。なぜなら、プロジェクトの管理方法に合わせて整理したいからだ。

- [ ] 設定画面でログの保存先フォルダを指定できる
- [ ] ファイル名フォーマット（日付・エージェント名等）を設定できる

---

### Epic 8: ブログ公開パイプライン

> **設計方針**: セッションログ（機械的）→ AIが人間が読みやすい技術ブログに変換 → 人間がレビュー・修正 → ワンクリックでZenn/Noteに公開

**US-8.1** [Should] 個人開発者として、セッションログを選択して技術ブログ記事の下書きをAIに自動生成させたい。なぜなら、機械的なセッションログを人間が読みやすい技術ブログに変換する手間を省きたいからだ。

- [ ] セッションログ（1件または複数）を選択してブログ下書き生成を実行できる
- [ ] AIがセッションログの内容を解釈し、読者向けの文体・構成に変換する
- [ ] タイトル、導入、本文、まとめの記事構成が自動生成される
- [ ] 生成された下書きが新規マークダウンファイルとして保存される

**US-8.2** [Should] 個人開発者として、生成されたブログ下書きをレビュー・修正したい。なぜなら、公開前に内容の正確性や表現を確認・調整したいからだ。

- [ ] 下書きがLive Previewエディタで開かれ、編集できる
- [ ] 下書きの状態（未レビュー/レビュー済み/公開済み）が管理される

**US-8.3** [Should] 個人開発者として、内部リンク `[[]]` やTechtite固有の記法がブログ公開時に自動変換されてほしい。なぜなら、外部プラットフォームで正しく表示されるようにしたいからだ。

- [ ] 内部リンク `[[ファイル名]]` が標準マークダウンリンクまたはプレーンテキストに変換される
- [ ] Techtite固有の記法が除去または標準形式に変換される
- [ ] 変換は公開時に自動実行され、元のファイルは変更されない

**US-8.4** [Should] 個人開発者として、レビュー済みのブログ記事をワンクリックでZennに公開したい。なぜなら、公開作業を最小限の手間で行いたいからだ。

- [ ] Zenn CLIまたはAPIの認証設定ができる
- [ ] ワンクリック（ボタン1つ）でZennに記事を公開できる
- [ ] Zennのfrontmatter（title, emoji, type, topics, published）が自動生成・付与される
- [ ] 公開成功・失敗のフィードバックが表示される

**US-8.5** [Could] 個人開発者として、レビュー済みのブログ記事をワンクリックでNoteに公開したい。なぜなら、Zenn以外のプラットフォームでも発信したいからだ。

- [ ] Note APIの認証設定ができる
- [ ] ワンクリック（ボタン1つ）でNoteに記事を公開できる
- [ ] 公開成功・失敗のフィードバックが表示される

---

### Epic 9: SNS連携

> **設計方針**: ブログ公開（Epic 8）のコンパクト・高頻度版。セッションログから短い要約を生成し、日常的にX/Threadsで発信する。

**US-9.1** [Should] 個人開発者として、セッションログやナレッジからSNS投稿用のコンパクトな要約をAIに自動生成させたい。なぜなら、日々の作業成果を手間なく高頻度でSNS発信したいからだ。

- [ ] セッションログやノートを選択して要約生成を実行できる
- [ ] AIが内容を解釈し、SNSに適したコンパクトな投稿文に変換する
- [ ] 生成された要約がプラットフォームの文字数制限内に収まる（X: 280文字カウント、全角=2カウントのため日本語実質140文字。Threads: 500文字）
- [ ] 生成された要約をレビュー・編集してから投稿できる

**US-9.2** [Should] 個人開発者として、レビュー済みの要約をワンクリックでXに投稿したい。なぜなら、技術的な知見をXのフォロワーに高頻度で発信したいからだ。

- [ ] X APIの認証設定ができる（OAuth）
- [ ] ワンクリック（ボタン1つ）でXに投稿できる
- [ ] 投稿成功・失敗のフィードバックが表示される

**US-9.3** [Could] 個人開発者として、レビュー済みの要約をワンクリックでThreadsに投稿したい。なぜなら、Xとは別のSNSでも情報を発信したいからだ。

- [ ] Threads APIの認証設定ができる
- [ ] ワンクリック（ボタン1つ）でThreadsに投稿できる
- [ ] 投稿成功・失敗のフィードバックが表示される

**US-9.4** [Could] 個人開発者として、SNS投稿のテンプレート（ハッシュタグ、定型文等）をカスタマイズしたい。なぜなら、自分のブランディングに合った投稿フォーマットを使いたいからだ。

- [ ] 投稿テンプレートを設定画面で編集できる
- [ ] テンプレートにハッシュタグ、ブログURL等の変数を使用できる
- [ ] プラットフォームごとに異なるテンプレートを設定できる

